var util = require('util'),
    fs = require('fs'),
    path = require('path'),
    uglify = require('uglify-js');

function Compiler(ast) {
  this.ast = ast;
};
exports.Compiler = Compiler;

//
// ### function compile (ast, options)
// #### @ast {Array} Candor AST
// #### @options {Object} **optional** options for uglify
// Compile AST into javascript code.
//
Compiler.compile = function compile(ast, options) {
  return new Compiler(ast).execute(options);
};

//
// ### function getRuntime ()
// Returns uglify's AST of Candor's runtime
//
Compiler.getRuntime = function getRuntime() {
  if (!Compiler.runtime) {
    var content = fs.readFileSync(path.resolve(__dirname, 'runtime.js'));
    Compiler.runtime = uglify.parser.parse(content.toString())[1];
  }
  return Compiler.runtime;
};
Compiler.runtime = null;

Compiler.esGlobals = [
  'NaN', 'Infinity', 'undefined', 'null',
  'parseInt', 'parseFloat', 'isNaN', 'isFinite', 'decodeURI',
  'decodeURIComponent', 'encodeURI', 'encodeURIComponent',
  'Object', 'Function', 'Array', 'String', 'Boolean', 'Number',
  'Date', 'RegExp', 'Error', 'EvalError', 'RangeError',
  'ReferenceError', 'SyntaxError', 'TypeError', 'URIError',
  'Math', 'JSON'
].reduce(function (obj, key) {
  obj[key] = true;

  return obj;
}, {});

//
// ### function computeScope ()
// Add var statements where needed (to implement lexical scoping)
//
Compiler.prototype.computeScope = function computeScope(ast) {
  var context = { vars: {}, parent: null };

  function lookup(name) {
    var current = context;

    while (current && current.vars[name] !== 'local') {
      current = current.parent;
    }

    return !!current;
  }

  function traverseLocals(node) {
    if (!Array.isArray(node)) return node;

    if (node[0] === 'function') return enterFunction(node);

    // If met assignment to ES global - shadow it with a local variable
    if (node[0] === 'assign' &&
        node[1][0] === 'name' &&
        Compiler.esGlobals.hasOwnProperty(node[1][1]) &&
        !lookup(node[1][1])) {
      context.vars[node[1][1]] = 'local';
    }

    // Non ES-global access create locals too
    if (node[0] === 'name' && !Compiler.esGlobals.hasOwnProperty(node[1]) &&
        !lookup(node[1])) {
      context.vars[node[1]] = 'local';
    }

    return node.map(traverseLocals);
  }

  function traverseGlobals(node) {
    if (!Array.isArray(node)) return node;

    if (node[0] === 'function') return node;

    if (node[0] === 'member' &&
        node[1][0] === 'name' && node[1][1] === 'global' &&
        node[2][0] === 'property' &&
        !lookup(node[2][1])) {
      return ['name', node[2][1]];
    }

    return node.map(traverseGlobals);
  }

  function enterFunction(node) {
    // Lift function's name to the parent scope
    if (node[1] !== null) context.vars[node[1]] = 'local';

    context = { vars: {}, parent: context };

    // Add arguments to context
    node[2].forEach(function(arg) {
      context.vars[arg] = 'arg';
    });

    // Find all local variables and add them to context
    var body = node[3].map(traverseLocals);

    // Replace global.a with a if it's not in context
    body = node[3].map(traverseGlobals);

    // Add variable declarations
    if (Object.keys(context.vars).length > 0) {
      body = [['var'].concat([Object.keys(context.vars).map(function(name) {
        return [name];
      })])].concat(body);
    }

    context = context.parent;

    return ['function', node[1], node[2], body];
  }

  return enterFunction(['function', null, [], ast])[3];
};

//
// ### function translate ()
// Translates candor's AST to uglify's AST
//
Compiler.prototype.translate = function translate(ast) {
  function traverse(node) {
    if (!Array.isArray(node)) {
      throw new TypeError('Incorrect AST node: ' + util.inspect(node));
    }

    function runtime(func, args, rawArgs) {
      return [
        'call',
        ['dot', ['name', '$$runtime'], '$' + func],
        rawArgs ? args : args.map(traverse)
      ];
    }

    switch (node[0]) {
      case 'var':
        // Not generated by parser! (Internal)
        return node;
      case 'number':
        return ['num', node[1]];
      case 'string':
        return node;
      case 'name':
        // Handle non-object (non-existent) access
        return node;
      case 'true':
      case 'false':
        return ['name', node[0]];
      case 'nil':
        return ['name', 'undefined'];
      case 'break':
      case 'continue':
        return [node[0], undefined];
      case 'return':
        return ['return', traverse(node[1])];
      case 'if':
      case 'while':
        return [node[0]].concat(node.slice(1).map(function(node) {
          if (!node) return;
          return traverse(node);
        }));
      case 'block':
        return ['block', node[1].map(function(node) {
          return ['stat', traverse(node)];
        })];
      case 'pre-unop':
        return ['unary-prefix', node[1], traverse(node[2])];
      case 'post-unop':
        return ['unary-postfix', node[1], traverse(node[2])];
      case 'binop':
        return ['binary', node[1], traverse(node[2]), traverse(node[3])];
      case 'assign':
        // Handle property set
        if (node[1][0] === 'member') {
          if (node[1][2][0] === 'property') {
            return runtime('setProperty', [
              node[1][1],
              ['string', node[1][2][1]],
              node[2]
            ]);
          } else {
            return runtime('setProperty', [
              node[1][1],
              node[1][2],
              node[2]
            ]);
          }
        }
        return ['assign', true, traverse(node[1]), traverse(node[2])];
      case 'member':
        if (node[2][0] === 'property') {
          return runtime('getProperty', [node[1], ['string', node[2][1]]]);
        } else {
          return runtime('getProperty', [node[1], node[2]]);
        }
      case 'call':
        // TODO: Handle vararg
        return runtime('call', [node[1], ['array', node[2]]]);
      case 'colonCall':
        // TODO: Handle vararg
        return runtime('colonCall', [
          node[1][1], // host object
          node[1][2], // property
          ['array', node[2]]
        ]);
      case 'function':
        // TODO: Handle vararg
        var fn = [
          'function',
          null,
          node[2].map(function(node) {
            return node[1];
          }),
          node[3].map(traverse)
        ];

        fn = runtime('markFunction', [fn], true);

        if (node[1] !== null) {
          return ['assign', true, node[1], fn];
        } else {
          return fn;
        }
      case 'object':
        return [
          'object',
          node[1].map(function(kv) {
            if (kv[0][1][0] === 'property') {
              return [['name', kv[0][1][1]], traverse(kv[1])];
            }
            return [kv[0][1], traverse(kv[1])];
          })
        ];
      case 'array':
        return [ 'array', node[1].map(traverse) ];
      case 'typeof':
      case 'keysof':
      case 'sizeof':
      case 'clone':
        return runtime(node[0], [node[1]]);
      case 'delete':
        return ['unary-prefix', 'delete', traverse(node[1])];
      default:
        throw new Error('Unexpected node: ' + util.inspect(node));
    }
  }

  return ['toplevel', [
    [ 'stat',
      [ 'call',
        [ 'function',
          null,
          [],
          Compiler.getRuntime().concat(traverse(['block', ast])[1])
        ],
        []
      ]
    ]
  ]];
};

//
// ### function execute ()
// Translates AST to the javascript code
//
Compiler.prototype.execute = function execute(options) {
  return uglify.uglify.gen_code(
    this.translate(this.computeScope(this.ast)),
    options
  );
};
